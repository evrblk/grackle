// Code generated by `monstera generate`. DO NOT EDIT.

package grackle

import (
	"context"
	corepb "github.com/evrblk/grackle/pkg/corepb"
	monstera "github.com/evrblk/monstera"
	monsterax "github.com/evrblk/monstera/x"
	proto "google.golang.org/protobuf/proto"
	"sync"
)

type GrackleMonsteraShardKeyCalculator interface {
	ListLocksShardKey(request *corepb.ListLocksRequest) []byte
	AcquireLockShardKey(request *corepb.AcquireLockRequest) []byte
	ReleaseLockShardKey(request *corepb.ReleaseLockRequest) []byte
	DeleteLockShardKey(request *corepb.DeleteLockRequest) []byte
	GetLockShardKey(request *corepb.GetLockRequest) []byte
	LocksDeleteNamespaceShardKey(request *corepb.LocksDeleteNamespaceRequest) []byte

	GetSemaphoreShardKey(request *corepb.GetSemaphoreRequest) []byte
	ListSemaphoresShardKey(request *corepb.ListSemaphoresRequest) []byte
	AcquireSemaphoreShardKey(request *corepb.AcquireSemaphoreRequest) []byte
	ReleaseSemaphoreShardKey(request *corepb.ReleaseSemaphoreRequest) []byte
	CreateSemaphoreShardKey(request *corepb.CreateSemaphoreRequest) []byte
	UpdateSemaphoreShardKey(request *corepb.UpdateSemaphoreRequest) []byte
	DeleteSemaphoreShardKey(request *corepb.DeleteSemaphoreRequest) []byte
	SemaphoresDeleteNamespaceShardKey(request *corepb.SemaphoresDeleteNamespaceRequest) []byte

	GetNamespaceShardKey(request *corepb.GetNamespaceRequest) []byte
	ListNamespacesShardKey(request *corepb.ListNamespacesRequest) []byte
	CreateNamespaceShardKey(request *corepb.CreateNamespaceRequest) []byte
	UpdateNamespaceShardKey(request *corepb.UpdateNamespaceRequest) []byte
	DeleteNamespaceShardKey(request *corepb.DeleteNamespaceRequest) []byte

	GetWaitGroupShardKey(request *corepb.GetWaitGroupRequest) []byte
	ListWaitGroupsShardKey(request *corepb.ListWaitGroupsRequest) []byte
	AddJobsToWaitGroupShardKey(request *corepb.AddJobsToWaitGroupRequest) []byte
	CompleteJobsFromWaitGroupShardKey(request *corepb.CompleteJobsFromWaitGroupRequest) []byte
	CreateWaitGroupShardKey(request *corepb.CreateWaitGroupRequest) []byte
	DeleteWaitGroupShardKey(request *corepb.DeleteWaitGroupRequest) []byte
	WaitGroupsDeleteNamespaceShardKey(request *corepb.WaitGroupsDeleteNamespaceRequest) []byte
}

type GrackleCoreApiMonsteraStub struct {
	monsteraClient     *monstera.MonsteraClient
	shardKeyCalculator GrackleMonsteraShardKeyCalculator
}

var _ GrackleCoreApi = &GrackleCoreApiMonsteraStub{}

func (s *GrackleCoreApiMonsteraStub) ListLocks(ctx context.Context, request *corepb.ListLocksRequest) (*corepb.ListLocksResponse, error) {
	readRequest := &corepb.GrackleReadRequest{Request: &corepb.GrackleReadRequest_ListLocksRequest{ListLocksRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ListLocksShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "GrackleLocks", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.GrackleReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.GrackleReadResponse_ListLocksResponse)
	if ok {
		return response.ListLocksResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) AcquireLock(ctx context.Context, request *corepb.AcquireLockRequest) (*corepb.AcquireLockResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_AcquireLockRequest{AcquireLockRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.AcquireLockShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleLocks", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_AcquireLockResponse)
	if ok {
		return response.AcquireLockResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) ReleaseLock(ctx context.Context, request *corepb.ReleaseLockRequest) (*corepb.ReleaseLockResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_ReleaseLockRequest{ReleaseLockRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ReleaseLockShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleLocks", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_ReleaseLockResponse)
	if ok {
		return response.ReleaseLockResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) DeleteLock(ctx context.Context, request *corepb.DeleteLockRequest) (*corepb.DeleteLockResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_DeleteLockRequest{DeleteLockRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.DeleteLockShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleLocks", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_DeleteLockResponse)
	if ok {
		return response.DeleteLockResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) GetLock(ctx context.Context, request *corepb.GetLockRequest) (*corepb.GetLockResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_GetLockRequest{GetLockRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.GetLockShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleLocks", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_GetLockResponse)
	if ok {
		return response.GetLockResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) RunLocksGarbageCollection(ctx context.Context, request *corepb.RunLocksGarbageCollectionRequest, shardId string) (*corepb.RunLocksGarbageCollectionResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_RunLocksGarbageCollectionRequest{RunLocksGarbageCollectionRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	responseBytes, err := s.monsteraClient.UpdateShard(ctx, "GrackleLocks", shardId, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_RunLocksGarbageCollectionResponse)
	if ok {
		return response.RunLocksGarbageCollectionResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) LocksDeleteNamespace(ctx context.Context, request *corepb.LocksDeleteNamespaceRequest) (*corepb.LocksDeleteNamespaceResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_LocksDeleteNamespaceRequest{LocksDeleteNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.LocksDeleteNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleLocks", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_LocksDeleteNamespaceResponse)
	if ok {
		return response.LocksDeleteNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) GetSemaphore(ctx context.Context, request *corepb.GetSemaphoreRequest) (*corepb.GetSemaphoreResponse, error) {
	readRequest := &corepb.GrackleReadRequest{Request: &corepb.GrackleReadRequest_GetSemaphoreRequest{GetSemaphoreRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.GetSemaphoreShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "GrackleSemaphores", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.GrackleReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.GrackleReadResponse_GetSemaphoreResponse)
	if ok {
		return response.GetSemaphoreResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) ListSemaphores(ctx context.Context, request *corepb.ListSemaphoresRequest) (*corepb.ListSemaphoresResponse, error) {
	readRequest := &corepb.GrackleReadRequest{Request: &corepb.GrackleReadRequest_ListSemaphoresRequest{ListSemaphoresRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ListSemaphoresShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "GrackleSemaphores", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.GrackleReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.GrackleReadResponse_ListSemaphoresResponse)
	if ok {
		return response.ListSemaphoresResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) AcquireSemaphore(ctx context.Context, request *corepb.AcquireSemaphoreRequest) (*corepb.AcquireSemaphoreResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_AcquireSemaphoreRequest{AcquireSemaphoreRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.AcquireSemaphoreShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleSemaphores", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_AcquireSemaphoreResponse)
	if ok {
		return response.AcquireSemaphoreResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) ReleaseSemaphore(ctx context.Context, request *corepb.ReleaseSemaphoreRequest) (*corepb.ReleaseSemaphoreResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_ReleaseSemaphoreRequest{ReleaseSemaphoreRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ReleaseSemaphoreShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleSemaphores", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_ReleaseSemaphoreResponse)
	if ok {
		return response.ReleaseSemaphoreResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) CreateSemaphore(ctx context.Context, request *corepb.CreateSemaphoreRequest) (*corepb.CreateSemaphoreResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_CreateSemaphoreRequest{CreateSemaphoreRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.CreateSemaphoreShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleSemaphores", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_CreateSemaphoreResponse)
	if ok {
		return response.CreateSemaphoreResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) UpdateSemaphore(ctx context.Context, request *corepb.UpdateSemaphoreRequest) (*corepb.UpdateSemaphoreResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_UpdateSemaphoreRequest{UpdateSemaphoreRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.UpdateSemaphoreShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleSemaphores", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_UpdateSemaphoreResponse)
	if ok {
		return response.UpdateSemaphoreResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) DeleteSemaphore(ctx context.Context, request *corepb.DeleteSemaphoreRequest) (*corepb.DeleteSemaphoreResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_DeleteSemaphoreRequest{DeleteSemaphoreRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.DeleteSemaphoreShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleSemaphores", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_DeleteSemaphoreResponse)
	if ok {
		return response.DeleteSemaphoreResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) RunSemaphoresGarbageCollection(ctx context.Context, request *corepb.RunSemaphoresGarbageCollectionRequest, shardId string) (*corepb.RunSemaphoresGarbageCollectionResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_RunSemaphoresGarbageCollectionRequest{RunSemaphoresGarbageCollectionRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	responseBytes, err := s.monsteraClient.UpdateShard(ctx, "GrackleSemaphores", shardId, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_RunSemaphoresGarbageCollectionResponse)
	if ok {
		return response.RunSemaphoresGarbageCollectionResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) SemaphoresDeleteNamespace(ctx context.Context, request *corepb.SemaphoresDeleteNamespaceRequest) (*corepb.SemaphoresDeleteNamespaceResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_SemaphoresDeleteNamespaceRequest{SemaphoresDeleteNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.SemaphoresDeleteNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleSemaphores", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_SemaphoresDeleteNamespaceResponse)
	if ok {
		return response.SemaphoresDeleteNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) GetNamespace(ctx context.Context, request *corepb.GetNamespaceRequest) (*corepb.GetNamespaceResponse, error) {
	readRequest := &corepb.GrackleReadRequest{Request: &corepb.GrackleReadRequest_GetNamespaceRequest{GetNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.GetNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "GrackleNamespaces", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.GrackleReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.GrackleReadResponse_GetNamespaceResponse)
	if ok {
		return response.GetNamespaceResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) ListNamespaces(ctx context.Context, request *corepb.ListNamespacesRequest) (*corepb.ListNamespacesResponse, error) {
	readRequest := &corepb.GrackleReadRequest{Request: &corepb.GrackleReadRequest_ListNamespacesRequest{ListNamespacesRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ListNamespacesShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "GrackleNamespaces", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.GrackleReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.GrackleReadResponse_ListNamespacesResponse)
	if ok {
		return response.ListNamespacesResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) CreateNamespace(ctx context.Context, request *corepb.CreateNamespaceRequest) (*corepb.CreateNamespaceResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_CreateNamespaceRequest{CreateNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.CreateNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleNamespaces", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_CreateNamespaceResponse)
	if ok {
		return response.CreateNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) UpdateNamespace(ctx context.Context, request *corepb.UpdateNamespaceRequest) (*corepb.UpdateNamespaceResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_UpdateNamespaceRequest{UpdateNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.UpdateNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleNamespaces", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_UpdateNamespaceResponse)
	if ok {
		return response.UpdateNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) DeleteNamespace(ctx context.Context, request *corepb.DeleteNamespaceRequest) (*corepb.DeleteNamespaceResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_DeleteNamespaceRequest{DeleteNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.DeleteNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleNamespaces", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_DeleteNamespaceResponse)
	if ok {
		return response.DeleteNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) GetWaitGroup(ctx context.Context, request *corepb.GetWaitGroupRequest) (*corepb.GetWaitGroupResponse, error) {
	readRequest := &corepb.GrackleReadRequest{Request: &corepb.GrackleReadRequest_GetWaitGroupRequest{GetWaitGroupRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.GetWaitGroupShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "GrackleWaitGroups", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.GrackleReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.GrackleReadResponse_GetWaitGroupResponse)
	if ok {
		return response.GetWaitGroupResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) ListWaitGroups(ctx context.Context, request *corepb.ListWaitGroupsRequest) (*corepb.ListWaitGroupsResponse, error) {
	readRequest := &corepb.GrackleReadRequest{Request: &corepb.GrackleReadRequest_ListWaitGroupsRequest{ListWaitGroupsRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ListWaitGroupsShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "GrackleWaitGroups", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.GrackleReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.GrackleReadResponse_ListWaitGroupsResponse)
	if ok {
		return response.ListWaitGroupsResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) AddJobsToWaitGroup(ctx context.Context, request *corepb.AddJobsToWaitGroupRequest) (*corepb.AddJobsToWaitGroupResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_AddJobsToWaitGroupRequest{AddJobsToWaitGroupRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.AddJobsToWaitGroupShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleWaitGroups", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_AddJobsToWaitGroupResponse)
	if ok {
		return response.AddJobsToWaitGroupResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) CompleteJobsFromWaitGroup(ctx context.Context, request *corepb.CompleteJobsFromWaitGroupRequest) (*corepb.CompleteJobsFromWaitGroupResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_CompleteJobsFromWaitGroupRequest{CompleteJobsFromWaitGroupRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.CompleteJobsFromWaitGroupShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleWaitGroups", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_CompleteJobsFromWaitGroupResponse)
	if ok {
		return response.CompleteJobsFromWaitGroupResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) CreateWaitGroup(ctx context.Context, request *corepb.CreateWaitGroupRequest) (*corepb.CreateWaitGroupResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_CreateWaitGroupRequest{CreateWaitGroupRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.CreateWaitGroupShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleWaitGroups", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_CreateWaitGroupResponse)
	if ok {
		return response.CreateWaitGroupResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) DeleteWaitGroup(ctx context.Context, request *corepb.DeleteWaitGroupRequest) (*corepb.DeleteWaitGroupResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_DeleteWaitGroupRequest{DeleteWaitGroupRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.DeleteWaitGroupShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleWaitGroups", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_DeleteWaitGroupResponse)
	if ok {
		return response.DeleteWaitGroupResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) RunWaitGroupsGarbageCollection(ctx context.Context, request *corepb.RunWaitGroupsGarbageCollectionRequest, shardId string) (*corepb.RunWaitGroupsGarbageCollectionResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_RunWaitGroupsGarbageCollectionRequest{RunWaitGroupsGarbageCollectionRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	responseBytes, err := s.monsteraClient.UpdateShard(ctx, "GrackleWaitGroups", shardId, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_RunWaitGroupsGarbageCollectionResponse)
	if ok {
		return response.RunWaitGroupsGarbageCollectionResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) WaitGroupsDeleteNamespace(ctx context.Context, request *corepb.WaitGroupsDeleteNamespaceRequest) (*corepb.WaitGroupsDeleteNamespaceResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_WaitGroupsDeleteNamespaceRequest{WaitGroupsDeleteNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.WaitGroupsDeleteNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleWaitGroups", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_WaitGroupsDeleteNamespaceResponse)
	if ok {
		return response.WaitGroupsDeleteNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func NewGrackleCoreApiMonsteraStub(monsteraClient *monstera.MonsteraClient, shardKeyCalculator GrackleMonsteraShardKeyCalculator) *GrackleCoreApiMonsteraStub {
	return &GrackleCoreApiMonsteraStub{monsteraClient: monsteraClient, shardKeyCalculator: shardKeyCalculator}
}

func nilifyIfEmpty(err *monsterax.Error) error {
	if err == nil || err.Code == monsterax.ErrorCode_INVALID || err.Code == monsterax.ErrorCode_OK {
		return nil
	} else {
		return err
	}
}

type GrackleCoreApiStandaloneStub struct {
	grackleLocksCore      GrackleLocksCoreApi
	grackleSemaphoresCore GrackleSemaphoresCoreApi
	grackleNamespacesCore GrackleNamespacesCoreApi
	grackleWaitGroupsCore GrackleWaitGroupsCoreApi

	mu sync.RWMutex
}

var _ GrackleCoreApi = &GrackleCoreApiStandaloneStub{}

func (s *GrackleCoreApiStandaloneStub) ListLocks(ctx context.Context, request *corepb.ListLocksRequest) (*corepb.ListLocksResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.grackleLocksCore.ListLocks(request)
}

func (s *GrackleCoreApiStandaloneStub) AcquireLock(ctx context.Context, request *corepb.AcquireLockRequest) (*corepb.AcquireLockResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleLocksCore.AcquireLock(request)
}

func (s *GrackleCoreApiStandaloneStub) ReleaseLock(ctx context.Context, request *corepb.ReleaseLockRequest) (*corepb.ReleaseLockResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleLocksCore.ReleaseLock(request)
}

func (s *GrackleCoreApiStandaloneStub) DeleteLock(ctx context.Context, request *corepb.DeleteLockRequest) (*corepb.DeleteLockResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleLocksCore.DeleteLock(request)
}

func (s *GrackleCoreApiStandaloneStub) GetLock(ctx context.Context, request *corepb.GetLockRequest) (*corepb.GetLockResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleLocksCore.GetLock(request)
}

func (s *GrackleCoreApiStandaloneStub) RunLocksGarbageCollection(ctx context.Context, request *corepb.RunLocksGarbageCollectionRequest, shardId string) (*corepb.RunLocksGarbageCollectionResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleLocksCore.RunLocksGarbageCollection(request)
}

func (s *GrackleCoreApiStandaloneStub) LocksDeleteNamespace(ctx context.Context, request *corepb.LocksDeleteNamespaceRequest) (*corepb.LocksDeleteNamespaceResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleLocksCore.LocksDeleteNamespace(request)
}

func (s *GrackleCoreApiStandaloneStub) GetSemaphore(ctx context.Context, request *corepb.GetSemaphoreRequest) (*corepb.GetSemaphoreResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.grackleSemaphoresCore.GetSemaphore(request)
}

func (s *GrackleCoreApiStandaloneStub) ListSemaphores(ctx context.Context, request *corepb.ListSemaphoresRequest) (*corepb.ListSemaphoresResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.grackleSemaphoresCore.ListSemaphores(request)
}

func (s *GrackleCoreApiStandaloneStub) AcquireSemaphore(ctx context.Context, request *corepb.AcquireSemaphoreRequest) (*corepb.AcquireSemaphoreResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleSemaphoresCore.AcquireSemaphore(request)
}

func (s *GrackleCoreApiStandaloneStub) ReleaseSemaphore(ctx context.Context, request *corepb.ReleaseSemaphoreRequest) (*corepb.ReleaseSemaphoreResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleSemaphoresCore.ReleaseSemaphore(request)
}

func (s *GrackleCoreApiStandaloneStub) CreateSemaphore(ctx context.Context, request *corepb.CreateSemaphoreRequest) (*corepb.CreateSemaphoreResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleSemaphoresCore.CreateSemaphore(request)
}

func (s *GrackleCoreApiStandaloneStub) UpdateSemaphore(ctx context.Context, request *corepb.UpdateSemaphoreRequest) (*corepb.UpdateSemaphoreResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleSemaphoresCore.UpdateSemaphore(request)
}

func (s *GrackleCoreApiStandaloneStub) DeleteSemaphore(ctx context.Context, request *corepb.DeleteSemaphoreRequest) (*corepb.DeleteSemaphoreResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleSemaphoresCore.DeleteSemaphore(request)
}

func (s *GrackleCoreApiStandaloneStub) RunSemaphoresGarbageCollection(ctx context.Context, request *corepb.RunSemaphoresGarbageCollectionRequest, shardId string) (*corepb.RunSemaphoresGarbageCollectionResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleSemaphoresCore.RunSemaphoresGarbageCollection(request)
}

func (s *GrackleCoreApiStandaloneStub) SemaphoresDeleteNamespace(ctx context.Context, request *corepb.SemaphoresDeleteNamespaceRequest) (*corepb.SemaphoresDeleteNamespaceResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleSemaphoresCore.SemaphoresDeleteNamespace(request)
}

func (s *GrackleCoreApiStandaloneStub) GetNamespace(ctx context.Context, request *corepb.GetNamespaceRequest) (*corepb.GetNamespaceResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.grackleNamespacesCore.GetNamespace(request)
}

func (s *GrackleCoreApiStandaloneStub) ListNamespaces(ctx context.Context, request *corepb.ListNamespacesRequest) (*corepb.ListNamespacesResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.grackleNamespacesCore.ListNamespaces(request)
}

func (s *GrackleCoreApiStandaloneStub) CreateNamespace(ctx context.Context, request *corepb.CreateNamespaceRequest) (*corepb.CreateNamespaceResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleNamespacesCore.CreateNamespace(request)
}

func (s *GrackleCoreApiStandaloneStub) UpdateNamespace(ctx context.Context, request *corepb.UpdateNamespaceRequest) (*corepb.UpdateNamespaceResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleNamespacesCore.UpdateNamespace(request)
}

func (s *GrackleCoreApiStandaloneStub) DeleteNamespace(ctx context.Context, request *corepb.DeleteNamespaceRequest) (*corepb.DeleteNamespaceResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleNamespacesCore.DeleteNamespace(request)
}

func (s *GrackleCoreApiStandaloneStub) GetWaitGroup(ctx context.Context, request *corepb.GetWaitGroupRequest) (*corepb.GetWaitGroupResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.grackleWaitGroupsCore.GetWaitGroup(request)
}

func (s *GrackleCoreApiStandaloneStub) ListWaitGroups(ctx context.Context, request *corepb.ListWaitGroupsRequest) (*corepb.ListWaitGroupsResponse, error) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	return s.grackleWaitGroupsCore.ListWaitGroups(request)
}

func (s *GrackleCoreApiStandaloneStub) AddJobsToWaitGroup(ctx context.Context, request *corepb.AddJobsToWaitGroupRequest) (*corepb.AddJobsToWaitGroupResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleWaitGroupsCore.AddJobsToWaitGroup(request)
}

func (s *GrackleCoreApiStandaloneStub) CompleteJobsFromWaitGroup(ctx context.Context, request *corepb.CompleteJobsFromWaitGroupRequest) (*corepb.CompleteJobsFromWaitGroupResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleWaitGroupsCore.CompleteJobsFromWaitGroup(request)
}

func (s *GrackleCoreApiStandaloneStub) CreateWaitGroup(ctx context.Context, request *corepb.CreateWaitGroupRequest) (*corepb.CreateWaitGroupResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleWaitGroupsCore.CreateWaitGroup(request)
}

func (s *GrackleCoreApiStandaloneStub) DeleteWaitGroup(ctx context.Context, request *corepb.DeleteWaitGroupRequest) (*corepb.DeleteWaitGroupResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleWaitGroupsCore.DeleteWaitGroup(request)
}

func (s *GrackleCoreApiStandaloneStub) RunWaitGroupsGarbageCollection(ctx context.Context, request *corepb.RunWaitGroupsGarbageCollectionRequest, shardId string) (*corepb.RunWaitGroupsGarbageCollectionResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleWaitGroupsCore.RunWaitGroupsGarbageCollection(request)
}

func (s *GrackleCoreApiStandaloneStub) WaitGroupsDeleteNamespace(ctx context.Context, request *corepb.WaitGroupsDeleteNamespaceRequest) (*corepb.WaitGroupsDeleteNamespaceResponse, error) {
	s.mu.Lock()
	defer s.mu.Unlock()

	return s.grackleWaitGroupsCore.WaitGroupsDeleteNamespace(request)
}

func NewGrackleCoreApiStandaloneStub(grackleLocksCore GrackleLocksCoreApi, grackleSemaphoresCore GrackleSemaphoresCoreApi, grackleNamespacesCore GrackleNamespacesCoreApi, grackleWaitGroupsCore GrackleWaitGroupsCoreApi) *GrackleCoreApiStandaloneStub {
	return &GrackleCoreApiStandaloneStub{grackleLocksCore: grackleLocksCore, grackleSemaphoresCore: grackleSemaphoresCore, grackleNamespacesCore: grackleNamespacesCore, grackleWaitGroupsCore: grackleWaitGroupsCore}
}
