// Code generated by `monstera generate`. DO NOT EDIT.

package grackle

import (
	"bytes"
	"context"
	"encoding/binary"
	"fmt"
	corepb "github.com/evrblk/grackle/pkg/corepb"
	monstera "github.com/evrblk/monstera"
	monsterax "github.com/evrblk/monstera/x"
	proto "google.golang.org/protobuf/proto"
	"sync"
)

type GrackleMonsteraShardKeyCalculator interface {
	ListLocksShardKey(request *corepb.ListLocksRequest) []byte
	AcquireLockShardKey(request *corepb.AcquireLockRequest) []byte
	ReleaseLockShardKey(request *corepb.ReleaseLockRequest) []byte
	DeleteLockShardKey(request *corepb.DeleteLockRequest) []byte
	GetLockShardKey(request *corepb.GetLockRequest) []byte
	LocksDeleteNamespaceShardKey(request *corepb.LocksDeleteNamespaceRequest) []byte

	GetSemaphoreShardKey(request *corepb.GetSemaphoreRequest) []byte
	ListSemaphoresShardKey(request *corepb.ListSemaphoresRequest) []byte
	AcquireSemaphoreShardKey(request *corepb.AcquireSemaphoreRequest) []byte
	ReleaseSemaphoreShardKey(request *corepb.ReleaseSemaphoreRequest) []byte
	CreateSemaphoreShardKey(request *corepb.CreateSemaphoreRequest) []byte
	UpdateSemaphoreShardKey(request *corepb.UpdateSemaphoreRequest) []byte
	DeleteSemaphoreShardKey(request *corepb.DeleteSemaphoreRequest) []byte
	SemaphoresDeleteNamespaceShardKey(request *corepb.SemaphoresDeleteNamespaceRequest) []byte

	GetNamespaceShardKey(request *corepb.GetNamespaceRequest) []byte
	ListNamespacesShardKey(request *corepb.ListNamespacesRequest) []byte
	CreateNamespaceShardKey(request *corepb.CreateNamespaceRequest) []byte
	UpdateNamespaceShardKey(request *corepb.UpdateNamespaceRequest) []byte
	DeleteNamespaceShardKey(request *corepb.DeleteNamespaceRequest) []byte

	GetWaitGroupShardKey(request *corepb.GetWaitGroupRequest) []byte
	ListWaitGroupsShardKey(request *corepb.ListWaitGroupsRequest) []byte
	AddJobsToWaitGroupShardKey(request *corepb.AddJobsToWaitGroupRequest) []byte
	CompleteJobsFromWaitGroupShardKey(request *corepb.CompleteJobsFromWaitGroupRequest) []byte
	CreateWaitGroupShardKey(request *corepb.CreateWaitGroupRequest) []byte
	DeleteWaitGroupShardKey(request *corepb.DeleteWaitGroupRequest) []byte
	WaitGroupsDeleteNamespaceShardKey(request *corepb.WaitGroupsDeleteNamespaceRequest) []byte
}

type GrackleCoreApiMonsteraStub struct {
	monsteraClient     *monstera.MonsteraClient
	shardKeyCalculator GrackleMonsteraShardKeyCalculator
}

var _ GrackleCoreApi = &GrackleCoreApiMonsteraStub{}

func (s *GrackleCoreApiMonsteraStub) ListLocks(ctx context.Context, request *corepb.ListLocksRequest) (*corepb.ListLocksResponse, error) {
	readRequest := &corepb.GrackleReadRequest{Request: &corepb.GrackleReadRequest_ListLocksRequest{ListLocksRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ListLocksShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "GrackleLocks", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.GrackleReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.GrackleReadResponse_ListLocksResponse)
	if ok {
		return response.ListLocksResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) AcquireLock(ctx context.Context, request *corepb.AcquireLockRequest) (*corepb.AcquireLockResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_AcquireLockRequest{AcquireLockRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.AcquireLockShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleLocks", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_AcquireLockResponse)
	if ok {
		return response.AcquireLockResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) ReleaseLock(ctx context.Context, request *corepb.ReleaseLockRequest) (*corepb.ReleaseLockResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_ReleaseLockRequest{ReleaseLockRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ReleaseLockShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleLocks", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_ReleaseLockResponse)
	if ok {
		return response.ReleaseLockResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) DeleteLock(ctx context.Context, request *corepb.DeleteLockRequest) (*corepb.DeleteLockResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_DeleteLockRequest{DeleteLockRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.DeleteLockShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleLocks", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_DeleteLockResponse)
	if ok {
		return response.DeleteLockResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) GetLock(ctx context.Context, request *corepb.GetLockRequest) (*corepb.GetLockResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_GetLockRequest{GetLockRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.GetLockShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleLocks", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_GetLockResponse)
	if ok {
		return response.GetLockResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) RunLocksGarbageCollection(ctx context.Context, request *corepb.RunLocksGarbageCollectionRequest, shardId string) (*corepb.RunLocksGarbageCollectionResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_RunLocksGarbageCollectionRequest{RunLocksGarbageCollectionRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	responseBytes, err := s.monsteraClient.UpdateShard(ctx, "GrackleLocks", shardId, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_RunLocksGarbageCollectionResponse)
	if ok {
		return response.RunLocksGarbageCollectionResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) LocksDeleteNamespace(ctx context.Context, request *corepb.LocksDeleteNamespaceRequest) (*corepb.LocksDeleteNamespaceResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_LocksDeleteNamespaceRequest{LocksDeleteNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.LocksDeleteNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleLocks", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_LocksDeleteNamespaceResponse)
	if ok {
		return response.LocksDeleteNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) GetSemaphore(ctx context.Context, request *corepb.GetSemaphoreRequest) (*corepb.GetSemaphoreResponse, error) {
	readRequest := &corepb.GrackleReadRequest{Request: &corepb.GrackleReadRequest_GetSemaphoreRequest{GetSemaphoreRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.GetSemaphoreShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "GrackleSemaphores", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.GrackleReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.GrackleReadResponse_GetSemaphoreResponse)
	if ok {
		return response.GetSemaphoreResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) ListSemaphores(ctx context.Context, request *corepb.ListSemaphoresRequest) (*corepb.ListSemaphoresResponse, error) {
	readRequest := &corepb.GrackleReadRequest{Request: &corepb.GrackleReadRequest_ListSemaphoresRequest{ListSemaphoresRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ListSemaphoresShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "GrackleSemaphores", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.GrackleReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.GrackleReadResponse_ListSemaphoresResponse)
	if ok {
		return response.ListSemaphoresResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) AcquireSemaphore(ctx context.Context, request *corepb.AcquireSemaphoreRequest) (*corepb.AcquireSemaphoreResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_AcquireSemaphoreRequest{AcquireSemaphoreRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.AcquireSemaphoreShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleSemaphores", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_AcquireSemaphoreResponse)
	if ok {
		return response.AcquireSemaphoreResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) ReleaseSemaphore(ctx context.Context, request *corepb.ReleaseSemaphoreRequest) (*corepb.ReleaseSemaphoreResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_ReleaseSemaphoreRequest{ReleaseSemaphoreRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ReleaseSemaphoreShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleSemaphores", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_ReleaseSemaphoreResponse)
	if ok {
		return response.ReleaseSemaphoreResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) CreateSemaphore(ctx context.Context, request *corepb.CreateSemaphoreRequest) (*corepb.CreateSemaphoreResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_CreateSemaphoreRequest{CreateSemaphoreRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.CreateSemaphoreShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleSemaphores", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_CreateSemaphoreResponse)
	if ok {
		return response.CreateSemaphoreResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) UpdateSemaphore(ctx context.Context, request *corepb.UpdateSemaphoreRequest) (*corepb.UpdateSemaphoreResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_UpdateSemaphoreRequest{UpdateSemaphoreRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.UpdateSemaphoreShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleSemaphores", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_UpdateSemaphoreResponse)
	if ok {
		return response.UpdateSemaphoreResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) DeleteSemaphore(ctx context.Context, request *corepb.DeleteSemaphoreRequest) (*corepb.DeleteSemaphoreResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_DeleteSemaphoreRequest{DeleteSemaphoreRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.DeleteSemaphoreShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleSemaphores", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_DeleteSemaphoreResponse)
	if ok {
		return response.DeleteSemaphoreResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) RunSemaphoresGarbageCollection(ctx context.Context, request *corepb.RunSemaphoresGarbageCollectionRequest, shardId string) (*corepb.RunSemaphoresGarbageCollectionResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_RunSemaphoresGarbageCollectionRequest{RunSemaphoresGarbageCollectionRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	responseBytes, err := s.monsteraClient.UpdateShard(ctx, "GrackleSemaphores", shardId, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_RunSemaphoresGarbageCollectionResponse)
	if ok {
		return response.RunSemaphoresGarbageCollectionResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) SemaphoresDeleteNamespace(ctx context.Context, request *corepb.SemaphoresDeleteNamespaceRequest) (*corepb.SemaphoresDeleteNamespaceResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_SemaphoresDeleteNamespaceRequest{SemaphoresDeleteNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.SemaphoresDeleteNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleSemaphores", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_SemaphoresDeleteNamespaceResponse)
	if ok {
		return response.SemaphoresDeleteNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) GetNamespace(ctx context.Context, request *corepb.GetNamespaceRequest) (*corepb.GetNamespaceResponse, error) {
	readRequest := &corepb.GrackleReadRequest{Request: &corepb.GrackleReadRequest_GetNamespaceRequest{GetNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.GetNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "GrackleNamespaces", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.GrackleReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.GrackleReadResponse_GetNamespaceResponse)
	if ok {
		return response.GetNamespaceResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) ListNamespaces(ctx context.Context, request *corepb.ListNamespacesRequest) (*corepb.ListNamespacesResponse, error) {
	readRequest := &corepb.GrackleReadRequest{Request: &corepb.GrackleReadRequest_ListNamespacesRequest{ListNamespacesRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ListNamespacesShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "GrackleNamespaces", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.GrackleReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.GrackleReadResponse_ListNamespacesResponse)
	if ok {
		return response.ListNamespacesResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) CreateNamespace(ctx context.Context, request *corepb.CreateNamespaceRequest) (*corepb.CreateNamespaceResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_CreateNamespaceRequest{CreateNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.CreateNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleNamespaces", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_CreateNamespaceResponse)
	if ok {
		return response.CreateNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) UpdateNamespace(ctx context.Context, request *corepb.UpdateNamespaceRequest) (*corepb.UpdateNamespaceResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_UpdateNamespaceRequest{UpdateNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.UpdateNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleNamespaces", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_UpdateNamespaceResponse)
	if ok {
		return response.UpdateNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) DeleteNamespace(ctx context.Context, request *corepb.DeleteNamespaceRequest) (*corepb.DeleteNamespaceResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_DeleteNamespaceRequest{DeleteNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.DeleteNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleNamespaces", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_DeleteNamespaceResponse)
	if ok {
		return response.DeleteNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) GetWaitGroup(ctx context.Context, request *corepb.GetWaitGroupRequest) (*corepb.GetWaitGroupResponse, error) {
	readRequest := &corepb.GrackleReadRequest{Request: &corepb.GrackleReadRequest_GetWaitGroupRequest{GetWaitGroupRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.GetWaitGroupShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "GrackleWaitGroups", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.GrackleReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.GrackleReadResponse_GetWaitGroupResponse)
	if ok {
		return response.GetWaitGroupResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) ListWaitGroups(ctx context.Context, request *corepb.ListWaitGroupsRequest) (*corepb.ListWaitGroupsResponse, error) {
	readRequest := &corepb.GrackleReadRequest{Request: &corepb.GrackleReadRequest_ListWaitGroupsRequest{ListWaitGroupsRequest: request}}
	requestBytes, err := proto.Marshal(readRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.ListWaitGroupsShardKey(request)

	responseBytes, err := s.monsteraClient.Read(ctx, "GrackleWaitGroups", shardKey, false, requestBytes)
	if err != nil {
		return nil, err
	}

	readResponse := &corepb.GrackleReadResponse{}
	err = proto.Unmarshal(responseBytes, readResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := readResponse.Response.(*corepb.GrackleReadResponse_ListWaitGroupsResponse)
	if ok {
		return response.ListWaitGroupsResponse, nilifyIfEmpty(readResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": readResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) AddJobsToWaitGroup(ctx context.Context, request *corepb.AddJobsToWaitGroupRequest) (*corepb.AddJobsToWaitGroupResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_AddJobsToWaitGroupRequest{AddJobsToWaitGroupRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.AddJobsToWaitGroupShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleWaitGroups", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_AddJobsToWaitGroupResponse)
	if ok {
		return response.AddJobsToWaitGroupResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) CompleteJobsFromWaitGroup(ctx context.Context, request *corepb.CompleteJobsFromWaitGroupRequest) (*corepb.CompleteJobsFromWaitGroupResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_CompleteJobsFromWaitGroupRequest{CompleteJobsFromWaitGroupRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.CompleteJobsFromWaitGroupShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleWaitGroups", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_CompleteJobsFromWaitGroupResponse)
	if ok {
		return response.CompleteJobsFromWaitGroupResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) CreateWaitGroup(ctx context.Context, request *corepb.CreateWaitGroupRequest) (*corepb.CreateWaitGroupResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_CreateWaitGroupRequest{CreateWaitGroupRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.CreateWaitGroupShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleWaitGroups", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_CreateWaitGroupResponse)
	if ok {
		return response.CreateWaitGroupResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) DeleteWaitGroup(ctx context.Context, request *corepb.DeleteWaitGroupRequest) (*corepb.DeleteWaitGroupResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_DeleteWaitGroupRequest{DeleteWaitGroupRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.DeleteWaitGroupShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleWaitGroups", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_DeleteWaitGroupResponse)
	if ok {
		return response.DeleteWaitGroupResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) RunWaitGroupsGarbageCollection(ctx context.Context, request *corepb.RunWaitGroupsGarbageCollectionRequest, shardId string) (*corepb.RunWaitGroupsGarbageCollectionResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_RunWaitGroupsGarbageCollectionRequest{RunWaitGroupsGarbageCollectionRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	responseBytes, err := s.monsteraClient.UpdateShard(ctx, "GrackleWaitGroups", shardId, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_RunWaitGroupsGarbageCollectionResponse)
	if ok {
		return response.RunWaitGroupsGarbageCollectionResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) WaitGroupsDeleteNamespace(ctx context.Context, request *corepb.WaitGroupsDeleteNamespaceRequest) (*corepb.WaitGroupsDeleteNamespaceResponse, error) {
	updateRequest := &corepb.GrackleUpdateRequest{Request: &corepb.GrackleUpdateRequest_WaitGroupsDeleteNamespaceRequest{WaitGroupsDeleteNamespaceRequest: request}}
	requestBytes, err := proto.Marshal(updateRequest)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to marshal request", map[string]string{"error": err.Error()})
	}

	shardKey := s.shardKeyCalculator.WaitGroupsDeleteNamespaceShardKey(request)

	responseBytes, err := s.monsteraClient.Update(ctx, "GrackleWaitGroups", shardKey, requestBytes)
	if err != nil {
		return nil, err
	}

	updateResponse := &corepb.GrackleUpdateResponse{}
	err = proto.Unmarshal(responseBytes, updateResponse)
	if err != nil {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "failed to unmarshal response", map[string]string{"error": err.Error()})
	}

	response, ok := updateResponse.Response.(*corepb.GrackleUpdateResponse_WaitGroupsDeleteNamespaceResponse)
	if ok {
		return response.WaitGroupsDeleteNamespaceResponse, nilifyIfEmpty(updateResponse.Error)
	} else {
		return nil, monsterax.NewErrorWithContext(monsterax.Internal, "invalid response type", map[string]string{"response": updateResponse.String()})
	}
}

func (s *GrackleCoreApiMonsteraStub) ListShards(applicationName string) ([]string, error) {
	shards, err := s.monsteraClient.ListShards(applicationName)
	if err != nil {
		return nil, err
	}
	shardIds := make([]string, len(shards))
	for i := range shards {
		shardIds[i] = shards[i].Id
	}
	return shardIds, nil
}

func NewGrackleCoreApiMonsteraStub(monsteraClient *monstera.MonsteraClient, shardKeyCalculator GrackleMonsteraShardKeyCalculator) *GrackleCoreApiMonsteraStub {
	return &GrackleCoreApiMonsteraStub{monsteraClient: monsteraClient, shardKeyCalculator: shardKeyCalculator}
}

func nilifyIfEmpty(err *monsterax.Error) error {
	if err == nil || err.Code == monsterax.ErrorCode_INVALID || err.Code == monsterax.ErrorCode_OK {
		return nil
	} else {
		return err
	}
}

type grackleLocksCoreNonclusteredAdapter struct {
	core       GrackleLocksCoreApi
	mu         sync.RWMutex
	id         string
	lowerBound []byte
	upperBound []byte
}

type grackleSemaphoresCoreNonclusteredAdapter struct {
	core       GrackleSemaphoresCoreApi
	mu         sync.RWMutex
	id         string
	lowerBound []byte
	upperBound []byte
}

type grackleNamespacesCoreNonclusteredAdapter struct {
	core       GrackleNamespacesCoreApi
	mu         sync.RWMutex
	id         string
	lowerBound []byte
	upperBound []byte
}

type grackleWaitGroupsCoreNonclusteredAdapter struct {
	core       GrackleWaitGroupsCoreApi
	mu         sync.RWMutex
	id         string
	lowerBound []byte
	upperBound []byte
}

type GrackleNonclusteredApplicationCoresFactory struct {
	GrackleLocksCoreFactoryFunc      func(shardId string, lowerBound []byte, upperBound []byte) GrackleLocksCoreApi
	GrackleSemaphoresCoreFactoryFunc func(shardId string, lowerBound []byte, upperBound []byte) GrackleSemaphoresCoreApi
	GrackleNamespacesCoreFactoryFunc func(shardId string, lowerBound []byte, upperBound []byte) GrackleNamespacesCoreApi
	GrackleWaitGroupsCoreFactoryFunc func(shardId string, lowerBound []byte, upperBound []byte) GrackleWaitGroupsCoreApi
}
type GrackleCoreApiNonclusteredStub struct {
	grackleLocksCores      []*grackleLocksCoreNonclusteredAdapter
	grackleSemaphoresCores []*grackleSemaphoresCoreNonclusteredAdapter
	grackleNamespacesCores []*grackleNamespacesCoreNonclusteredAdapter
	grackleWaitGroupsCores []*grackleWaitGroupsCoreNonclusteredAdapter

	shardKeyCalculator GrackleMonsteraShardKeyCalculator
}

var _ GrackleCoreApi = &GrackleCoreApiNonclusteredStub{}

func (s *GrackleCoreApiNonclusteredStub) ListLocks(ctx context.Context, request *corepb.ListLocksRequest) (*corepb.ListLocksResponse, error) {
	shardKey := s.shardKeyCalculator.ListLocksShardKey(request)

	for _, adapter := range s.grackleLocksCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.RLock()
			defer adapter.mu.RUnlock()

			return adapter.core.ListLocks(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) AcquireLock(ctx context.Context, request *corepb.AcquireLockRequest) (*corepb.AcquireLockResponse, error) {
	shardKey := s.shardKeyCalculator.AcquireLockShardKey(request)

	for _, adapter := range s.grackleLocksCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.AcquireLock(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) ReleaseLock(ctx context.Context, request *corepb.ReleaseLockRequest) (*corepb.ReleaseLockResponse, error) {
	shardKey := s.shardKeyCalculator.ReleaseLockShardKey(request)

	for _, adapter := range s.grackleLocksCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.ReleaseLock(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) DeleteLock(ctx context.Context, request *corepb.DeleteLockRequest) (*corepb.DeleteLockResponse, error) {
	shardKey := s.shardKeyCalculator.DeleteLockShardKey(request)

	for _, adapter := range s.grackleLocksCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.DeleteLock(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) GetLock(ctx context.Context, request *corepb.GetLockRequest) (*corepb.GetLockResponse, error) {
	shardKey := s.shardKeyCalculator.GetLockShardKey(request)

	for _, adapter := range s.grackleLocksCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.GetLock(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) RunLocksGarbageCollection(ctx context.Context, request *corepb.RunLocksGarbageCollectionRequest, shardId string) (*corepb.RunLocksGarbageCollectionResponse, error) {
	for _, adapter := range s.grackleLocksCores {
		if adapter.id == shardId {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.RunLocksGarbageCollection(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardId: %s", shardId)
}

func (s *GrackleCoreApiNonclusteredStub) LocksDeleteNamespace(ctx context.Context, request *corepb.LocksDeleteNamespaceRequest) (*corepb.LocksDeleteNamespaceResponse, error) {
	shardKey := s.shardKeyCalculator.LocksDeleteNamespaceShardKey(request)

	for _, adapter := range s.grackleLocksCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.LocksDeleteNamespace(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) GetSemaphore(ctx context.Context, request *corepb.GetSemaphoreRequest) (*corepb.GetSemaphoreResponse, error) {
	shardKey := s.shardKeyCalculator.GetSemaphoreShardKey(request)

	for _, adapter := range s.grackleSemaphoresCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.RLock()
			defer adapter.mu.RUnlock()

			return adapter.core.GetSemaphore(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) ListSemaphores(ctx context.Context, request *corepb.ListSemaphoresRequest) (*corepb.ListSemaphoresResponse, error) {
	shardKey := s.shardKeyCalculator.ListSemaphoresShardKey(request)

	for _, adapter := range s.grackleSemaphoresCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.RLock()
			defer adapter.mu.RUnlock()

			return adapter.core.ListSemaphores(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) AcquireSemaphore(ctx context.Context, request *corepb.AcquireSemaphoreRequest) (*corepb.AcquireSemaphoreResponse, error) {
	shardKey := s.shardKeyCalculator.AcquireSemaphoreShardKey(request)

	for _, adapter := range s.grackleSemaphoresCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.AcquireSemaphore(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) ReleaseSemaphore(ctx context.Context, request *corepb.ReleaseSemaphoreRequest) (*corepb.ReleaseSemaphoreResponse, error) {
	shardKey := s.shardKeyCalculator.ReleaseSemaphoreShardKey(request)

	for _, adapter := range s.grackleSemaphoresCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.ReleaseSemaphore(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) CreateSemaphore(ctx context.Context, request *corepb.CreateSemaphoreRequest) (*corepb.CreateSemaphoreResponse, error) {
	shardKey := s.shardKeyCalculator.CreateSemaphoreShardKey(request)

	for _, adapter := range s.grackleSemaphoresCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.CreateSemaphore(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) UpdateSemaphore(ctx context.Context, request *corepb.UpdateSemaphoreRequest) (*corepb.UpdateSemaphoreResponse, error) {
	shardKey := s.shardKeyCalculator.UpdateSemaphoreShardKey(request)

	for _, adapter := range s.grackleSemaphoresCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.UpdateSemaphore(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) DeleteSemaphore(ctx context.Context, request *corepb.DeleteSemaphoreRequest) (*corepb.DeleteSemaphoreResponse, error) {
	shardKey := s.shardKeyCalculator.DeleteSemaphoreShardKey(request)

	for _, adapter := range s.grackleSemaphoresCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.DeleteSemaphore(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) RunSemaphoresGarbageCollection(ctx context.Context, request *corepb.RunSemaphoresGarbageCollectionRequest, shardId string) (*corepb.RunSemaphoresGarbageCollectionResponse, error) {
	for _, adapter := range s.grackleSemaphoresCores {
		if adapter.id == shardId {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.RunSemaphoresGarbageCollection(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardId: %s", shardId)
}

func (s *GrackleCoreApiNonclusteredStub) SemaphoresDeleteNamespace(ctx context.Context, request *corepb.SemaphoresDeleteNamespaceRequest) (*corepb.SemaphoresDeleteNamespaceResponse, error) {
	shardKey := s.shardKeyCalculator.SemaphoresDeleteNamespaceShardKey(request)

	for _, adapter := range s.grackleSemaphoresCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.SemaphoresDeleteNamespace(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) GetNamespace(ctx context.Context, request *corepb.GetNamespaceRequest) (*corepb.GetNamespaceResponse, error) {
	shardKey := s.shardKeyCalculator.GetNamespaceShardKey(request)

	for _, adapter := range s.grackleNamespacesCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.RLock()
			defer adapter.mu.RUnlock()

			return adapter.core.GetNamespace(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) ListNamespaces(ctx context.Context, request *corepb.ListNamespacesRequest) (*corepb.ListNamespacesResponse, error) {
	shardKey := s.shardKeyCalculator.ListNamespacesShardKey(request)

	for _, adapter := range s.grackleNamespacesCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.RLock()
			defer adapter.mu.RUnlock()

			return adapter.core.ListNamespaces(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) CreateNamespace(ctx context.Context, request *corepb.CreateNamespaceRequest) (*corepb.CreateNamespaceResponse, error) {
	shardKey := s.shardKeyCalculator.CreateNamespaceShardKey(request)

	for _, adapter := range s.grackleNamespacesCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.CreateNamespace(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) UpdateNamespace(ctx context.Context, request *corepb.UpdateNamespaceRequest) (*corepb.UpdateNamespaceResponse, error) {
	shardKey := s.shardKeyCalculator.UpdateNamespaceShardKey(request)

	for _, adapter := range s.grackleNamespacesCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.UpdateNamespace(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) DeleteNamespace(ctx context.Context, request *corepb.DeleteNamespaceRequest) (*corepb.DeleteNamespaceResponse, error) {
	shardKey := s.shardKeyCalculator.DeleteNamespaceShardKey(request)

	for _, adapter := range s.grackleNamespacesCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.DeleteNamespace(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) GetWaitGroup(ctx context.Context, request *corepb.GetWaitGroupRequest) (*corepb.GetWaitGroupResponse, error) {
	shardKey := s.shardKeyCalculator.GetWaitGroupShardKey(request)

	for _, adapter := range s.grackleWaitGroupsCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.RLock()
			defer adapter.mu.RUnlock()

			return adapter.core.GetWaitGroup(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) ListWaitGroups(ctx context.Context, request *corepb.ListWaitGroupsRequest) (*corepb.ListWaitGroupsResponse, error) {
	shardKey := s.shardKeyCalculator.ListWaitGroupsShardKey(request)

	for _, adapter := range s.grackleWaitGroupsCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.RLock()
			defer adapter.mu.RUnlock()

			return adapter.core.ListWaitGroups(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) AddJobsToWaitGroup(ctx context.Context, request *corepb.AddJobsToWaitGroupRequest) (*corepb.AddJobsToWaitGroupResponse, error) {
	shardKey := s.shardKeyCalculator.AddJobsToWaitGroupShardKey(request)

	for _, adapter := range s.grackleWaitGroupsCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.AddJobsToWaitGroup(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) CompleteJobsFromWaitGroup(ctx context.Context, request *corepb.CompleteJobsFromWaitGroupRequest) (*corepb.CompleteJobsFromWaitGroupResponse, error) {
	shardKey := s.shardKeyCalculator.CompleteJobsFromWaitGroupShardKey(request)

	for _, adapter := range s.grackleWaitGroupsCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.CompleteJobsFromWaitGroup(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) CreateWaitGroup(ctx context.Context, request *corepb.CreateWaitGroupRequest) (*corepb.CreateWaitGroupResponse, error) {
	shardKey := s.shardKeyCalculator.CreateWaitGroupShardKey(request)

	for _, adapter := range s.grackleWaitGroupsCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.CreateWaitGroup(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) DeleteWaitGroup(ctx context.Context, request *corepb.DeleteWaitGroupRequest) (*corepb.DeleteWaitGroupResponse, error) {
	shardKey := s.shardKeyCalculator.DeleteWaitGroupShardKey(request)

	for _, adapter := range s.grackleWaitGroupsCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.DeleteWaitGroup(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) RunWaitGroupsGarbageCollection(ctx context.Context, request *corepb.RunWaitGroupsGarbageCollectionRequest, shardId string) (*corepb.RunWaitGroupsGarbageCollectionResponse, error) {
	for _, adapter := range s.grackleWaitGroupsCores {
		if adapter.id == shardId {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.RunWaitGroupsGarbageCollection(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardId: %s", shardId)
}

func (s *GrackleCoreApiNonclusteredStub) WaitGroupsDeleteNamespace(ctx context.Context, request *corepb.WaitGroupsDeleteNamespaceRequest) (*corepb.WaitGroupsDeleteNamespaceResponse, error) {
	shardKey := s.shardKeyCalculator.WaitGroupsDeleteNamespaceShardKey(request)

	for _, adapter := range s.grackleWaitGroupsCores {
		if bytes.Compare(shardKey, adapter.upperBound) <= 0 && bytes.Compare(shardKey, adapter.lowerBound) >= 0 {
			adapter.mu.Lock()
			defer adapter.mu.Unlock()

			return adapter.core.WaitGroupsDeleteNamespace(request)
		}
	}

	return nil, fmt.Errorf("no shard found for shardKey: %s", shardKey)
}

func (s *GrackleCoreApiNonclusteredStub) ListShards(applicationName string) ([]string, error) {
	switch applicationName {
	case "GrackleLocks":
		shardIds := make([]string, len(s.grackleLocksCores))
		for i := range s.grackleLocksCores {
			shardIds[i] = s.grackleLocksCores[i].id
		}
		return shardIds, nil
	case "GrackleSemaphores":
		shardIds := make([]string, len(s.grackleSemaphoresCores))
		for i := range s.grackleSemaphoresCores {
			shardIds[i] = s.grackleSemaphoresCores[i].id
		}
		return shardIds, nil
	case "GrackleNamespaces":
		shardIds := make([]string, len(s.grackleNamespacesCores))
		for i := range s.grackleNamespacesCores {
			shardIds[i] = s.grackleNamespacesCores[i].id
		}
		return shardIds, nil
	case "GrackleWaitGroups":
		shardIds := make([]string, len(s.grackleWaitGroupsCores))
		for i := range s.grackleWaitGroupsCores {
			shardIds[i] = s.grackleWaitGroupsCores[i].id
		}
		return shardIds, nil
	default:
		return nil, fmt.Errorf("application not found: %s", applicationName)
	}
}

func NewGrackleCoreApiNonclusteredStub(shardsPerApp int, coresFactory *GrackleNonclusteredApplicationCoresFactory, shardKeyCalculator GrackleMonsteraShardKeyCalculator) *GrackleCoreApiNonclusteredStub {
	grackleLocksCores := make([]*grackleLocksCoreNonclusteredAdapter, shardsPerApp)
	grackleSemaphoresCores := make([]*grackleSemaphoresCoreNonclusteredAdapter, shardsPerApp)
	grackleNamespacesCores := make([]*grackleNamespacesCoreNonclusteredAdapter, shardsPerApp)
	grackleWaitGroupsCores := make([]*grackleWaitGroupsCoreNonclusteredAdapter, shardsPerApp)

	shardSize := monstera.KeyspacePerApplication / shardsPerApp
	for i := 0; i < shardsPerApp; i++ {
		lower := uint32(i * shardSize)
		upper := uint32((i+1)*shardSize - 1)
		lowerBound := make([]byte, 4)
		upperBound := make([]byte, 4)
		binary.BigEndian.PutUint32(lowerBound, lower)
		binary.BigEndian.PutUint32(upperBound, upper)

		sl, su := monstera.ShortenBounds(lowerBound, upperBound)

		grackleLocksShardId := fmt.Sprintf("%s_%x_%x", "GrackleLocks", sl, su)
		grackleLocksCores[i] = &grackleLocksCoreNonclusteredAdapter{core: coresFactory.GrackleLocksCoreFactoryFunc(grackleLocksShardId, lowerBound, upperBound), id: grackleLocksShardId, lowerBound: lowerBound, upperBound: upperBound}

		grackleSemaphoresShardId := fmt.Sprintf("%s_%x_%x", "GrackleSemaphores", sl, su)
		grackleSemaphoresCores[i] = &grackleSemaphoresCoreNonclusteredAdapter{core: coresFactory.GrackleSemaphoresCoreFactoryFunc(grackleSemaphoresShardId, lowerBound, upperBound), id: grackleSemaphoresShardId, lowerBound: lowerBound, upperBound: upperBound}

		grackleNamespacesShardId := fmt.Sprintf("%s_%x_%x", "GrackleNamespaces", sl, su)
		grackleNamespacesCores[i] = &grackleNamespacesCoreNonclusteredAdapter{core: coresFactory.GrackleNamespacesCoreFactoryFunc(grackleNamespacesShardId, lowerBound, upperBound), id: grackleNamespacesShardId, lowerBound: lowerBound, upperBound: upperBound}

		grackleWaitGroupsShardId := fmt.Sprintf("%s_%x_%x", "GrackleWaitGroups", sl, su)
		grackleWaitGroupsCores[i] = &grackleWaitGroupsCoreNonclusteredAdapter{core: coresFactory.GrackleWaitGroupsCoreFactoryFunc(grackleWaitGroupsShardId, lowerBound, upperBound), id: grackleWaitGroupsShardId, lowerBound: lowerBound, upperBound: upperBound}

	}
	return &GrackleCoreApiNonclusteredStub{grackleLocksCores: grackleLocksCores, grackleSemaphoresCores: grackleSemaphoresCores, grackleNamespacesCores: grackleNamespacesCores, grackleWaitGroupsCores: grackleWaitGroupsCores, shardKeyCalculator: shardKeyCalculator}
}
