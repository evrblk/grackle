// Code generated by `monstera generate`. DO NOT EDIT.

package grackle

import (
	corepb "github.com/evrblk/grackle/pkg/corepb"
	monstera "github.com/evrblk/monstera"
	monsterax "github.com/evrblk/monstera/x"
	prometheus "github.com/prometheus/client_golang/prometheus"
	proto "google.golang.org/protobuf/proto"
	"io"
	"time"
)

var monsteraCoreMethodDuration = prometheus.NewHistogramVec(prometheus.HistogramOpts{
	Help:                            "Monstera core method duration",
	Name:                            "monstera_core_method_duration_seconds",
	NativeHistogramBucketFactor:     1.1,
	NativeHistogramMaxBucketNumber:  100,
	NativeHistogramMinResetDuration: time.Hour,
}, []string{"core", "method", "shard", "replica"})

type GrackleLocksCoreAdapter struct {
	shardId   string
	replicaId string

	grackleLocksCore GrackleLocksCoreApi
}

var _ monstera.ApplicationCore = &GrackleLocksCoreAdapter{}

func NewGrackleLocksCoreAdapter(shardId string, replicaId string, grackleLocksCore GrackleLocksCoreApi) *GrackleLocksCoreAdapter {
	return &GrackleLocksCoreAdapter{
		grackleLocksCore: grackleLocksCore,
		replicaId:        replicaId,
		shardId:          shardId,
	}
}

func (a *GrackleLocksCoreAdapter) Snapshot() monstera.ApplicationCoreSnapshot {
	defer monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleLocks", "Snapshot", a.shardId, a.replicaId), time.Now())

	return a.grackleLocksCore.Snapshot()
}

func (a *GrackleLocksCoreAdapter) Restore(r io.ReadCloser) error {
	defer monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleLocks", "Restore", a.shardId, a.replicaId), time.Now())

	return a.grackleLocksCore.Restore(r)
}

func (a *GrackleLocksCoreAdapter) Close() {
	a.grackleLocksCore.Close()
}

func (a *GrackleLocksCoreAdapter) Update(request []byte) []byte {
	updateRequest := &corepb.GrackleUpdateRequest{}
	updateResponse := &corepb.GrackleUpdateResponse{}

	err := proto.Unmarshal(request, updateRequest)
	if err != nil {
		panic(err)
	}

	t1 := time.Now()

	switch req := updateRequest.Request.(type) {
	case *corepb.GrackleUpdateRequest_AcquireLockRequest:
		r, err := a.grackleLocksCore.AcquireLock(req.AcquireLockRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleLocks", "AcquireLock", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_AcquireLockResponse{AcquireLockResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_ReleaseLockRequest:
		r, err := a.grackleLocksCore.ReleaseLock(req.ReleaseLockRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleLocks", "ReleaseLock", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_ReleaseLockResponse{ReleaseLockResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_DeleteLockRequest:
		r, err := a.grackleLocksCore.DeleteLock(req.DeleteLockRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleLocks", "DeleteLock", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_DeleteLockResponse{DeleteLockResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_GetLockRequest:
		r, err := a.grackleLocksCore.GetLock(req.GetLockRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleLocks", "GetLock", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_GetLockResponse{GetLockResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_RunLocksGarbageCollectionRequest:
		r, err := a.grackleLocksCore.RunLocksGarbageCollection(req.RunLocksGarbageCollectionRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleLocks", "RunLocksGarbageCollection", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_RunLocksGarbageCollectionResponse{RunLocksGarbageCollectionResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_LocksDeleteNamespaceRequest:
		r, err := a.grackleLocksCore.LocksDeleteNamespace(req.LocksDeleteNamespaceRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleLocks", "LocksDeleteNamespace", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_LocksDeleteNamespaceResponse{LocksDeleteNamespaceResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(updateResponse)
	if err != nil {
		panic(err)
	}

	return response
}

func (a *GrackleLocksCoreAdapter) Read(request []byte) []byte {
	readRequest := &corepb.GrackleReadRequest{}
	readResponse := &corepb.GrackleReadResponse{}

	err := proto.Unmarshal(request, readRequest)
	if err != nil {
		panic(err)
	}

	t1 := time.Now()

	switch req := readRequest.Request.(type) {
	case *corepb.GrackleReadRequest_ListLocksRequest:
		r, err := a.grackleLocksCore.ListLocks(req.ListLocksRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleLocks", "ListLocks", a.shardId, a.replicaId), t1)
		readResponse.Response = &corepb.GrackleReadResponse_ListLocksResponse{ListLocksResponse: r}
		readResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(readResponse)
	if err != nil {
		panic(err)
	}

	return response
}

type GrackleSemaphoresCoreAdapter struct {
	shardId   string
	replicaId string

	grackleSemaphoresCore GrackleSemaphoresCoreApi
}

var _ monstera.ApplicationCore = &GrackleSemaphoresCoreAdapter{}

func NewGrackleSemaphoresCoreAdapter(shardId string, replicaId string, grackleSemaphoresCore GrackleSemaphoresCoreApi) *GrackleSemaphoresCoreAdapter {
	return &GrackleSemaphoresCoreAdapter{
		grackleSemaphoresCore: grackleSemaphoresCore,
		replicaId:             replicaId,
		shardId:               shardId,
	}
}

func (a *GrackleSemaphoresCoreAdapter) Snapshot() monstera.ApplicationCoreSnapshot {
	defer monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleSemaphores", "Snapshot", a.shardId, a.replicaId), time.Now())

	return a.grackleSemaphoresCore.Snapshot()
}

func (a *GrackleSemaphoresCoreAdapter) Restore(r io.ReadCloser) error {
	defer monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleSemaphores", "Restore", a.shardId, a.replicaId), time.Now())

	return a.grackleSemaphoresCore.Restore(r)
}

func (a *GrackleSemaphoresCoreAdapter) Close() {
	a.grackleSemaphoresCore.Close()
}

func (a *GrackleSemaphoresCoreAdapter) Update(request []byte) []byte {
	updateRequest := &corepb.GrackleUpdateRequest{}
	updateResponse := &corepb.GrackleUpdateResponse{}

	err := proto.Unmarshal(request, updateRequest)
	if err != nil {
		panic(err)
	}

	t1 := time.Now()

	switch req := updateRequest.Request.(type) {
	case *corepb.GrackleUpdateRequest_AcquireSemaphoreRequest:
		r, err := a.grackleSemaphoresCore.AcquireSemaphore(req.AcquireSemaphoreRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleSemaphores", "AcquireSemaphore", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_AcquireSemaphoreResponse{AcquireSemaphoreResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_ReleaseSemaphoreRequest:
		r, err := a.grackleSemaphoresCore.ReleaseSemaphore(req.ReleaseSemaphoreRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleSemaphores", "ReleaseSemaphore", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_ReleaseSemaphoreResponse{ReleaseSemaphoreResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_CreateSemaphoreRequest:
		r, err := a.grackleSemaphoresCore.CreateSemaphore(req.CreateSemaphoreRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleSemaphores", "CreateSemaphore", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_CreateSemaphoreResponse{CreateSemaphoreResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_UpdateSemaphoreRequest:
		r, err := a.grackleSemaphoresCore.UpdateSemaphore(req.UpdateSemaphoreRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleSemaphores", "UpdateSemaphore", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_UpdateSemaphoreResponse{UpdateSemaphoreResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_DeleteSemaphoreRequest:
		r, err := a.grackleSemaphoresCore.DeleteSemaphore(req.DeleteSemaphoreRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleSemaphores", "DeleteSemaphore", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_DeleteSemaphoreResponse{DeleteSemaphoreResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_RunSemaphoresGarbageCollectionRequest:
		r, err := a.grackleSemaphoresCore.RunSemaphoresGarbageCollection(req.RunSemaphoresGarbageCollectionRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleSemaphores", "RunSemaphoresGarbageCollection", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_RunSemaphoresGarbageCollectionResponse{RunSemaphoresGarbageCollectionResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_SemaphoresDeleteNamespaceRequest:
		r, err := a.grackleSemaphoresCore.SemaphoresDeleteNamespace(req.SemaphoresDeleteNamespaceRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleSemaphores", "SemaphoresDeleteNamespace", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_SemaphoresDeleteNamespaceResponse{SemaphoresDeleteNamespaceResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(updateResponse)
	if err != nil {
		panic(err)
	}

	return response
}

func (a *GrackleSemaphoresCoreAdapter) Read(request []byte) []byte {
	readRequest := &corepb.GrackleReadRequest{}
	readResponse := &corepb.GrackleReadResponse{}

	err := proto.Unmarshal(request, readRequest)
	if err != nil {
		panic(err)
	}

	t1 := time.Now()

	switch req := readRequest.Request.(type) {
	case *corepb.GrackleReadRequest_GetSemaphoreRequest:
		r, err := a.grackleSemaphoresCore.GetSemaphore(req.GetSemaphoreRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleSemaphores", "GetSemaphore", a.shardId, a.replicaId), t1)
		readResponse.Response = &corepb.GrackleReadResponse_GetSemaphoreResponse{GetSemaphoreResponse: r}
		readResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleReadRequest_ListSemaphoresRequest:
		r, err := a.grackleSemaphoresCore.ListSemaphores(req.ListSemaphoresRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleSemaphores", "ListSemaphores", a.shardId, a.replicaId), t1)
		readResponse.Response = &corepb.GrackleReadResponse_ListSemaphoresResponse{ListSemaphoresResponse: r}
		readResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(readResponse)
	if err != nil {
		panic(err)
	}

	return response
}

type GrackleNamespacesCoreAdapter struct {
	shardId   string
	replicaId string

	grackleNamespacesCore GrackleNamespacesCoreApi
}

var _ monstera.ApplicationCore = &GrackleNamespacesCoreAdapter{}

func NewGrackleNamespacesCoreAdapter(shardId string, replicaId string, grackleNamespacesCore GrackleNamespacesCoreApi) *GrackleNamespacesCoreAdapter {
	return &GrackleNamespacesCoreAdapter{
		grackleNamespacesCore: grackleNamespacesCore,
		replicaId:             replicaId,
		shardId:               shardId,
	}
}

func (a *GrackleNamespacesCoreAdapter) Snapshot() monstera.ApplicationCoreSnapshot {
	defer monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleNamespaces", "Snapshot", a.shardId, a.replicaId), time.Now())

	return a.grackleNamespacesCore.Snapshot()
}

func (a *GrackleNamespacesCoreAdapter) Restore(r io.ReadCloser) error {
	defer monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleNamespaces", "Restore", a.shardId, a.replicaId), time.Now())

	return a.grackleNamespacesCore.Restore(r)
}

func (a *GrackleNamespacesCoreAdapter) Close() {
	a.grackleNamespacesCore.Close()
}

func (a *GrackleNamespacesCoreAdapter) Update(request []byte) []byte {
	updateRequest := &corepb.GrackleUpdateRequest{}
	updateResponse := &corepb.GrackleUpdateResponse{}

	err := proto.Unmarshal(request, updateRequest)
	if err != nil {
		panic(err)
	}

	t1 := time.Now()

	switch req := updateRequest.Request.(type) {
	case *corepb.GrackleUpdateRequest_CreateNamespaceRequest:
		r, err := a.grackleNamespacesCore.CreateNamespace(req.CreateNamespaceRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleNamespaces", "CreateNamespace", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_CreateNamespaceResponse{CreateNamespaceResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_UpdateNamespaceRequest:
		r, err := a.grackleNamespacesCore.UpdateNamespace(req.UpdateNamespaceRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleNamespaces", "UpdateNamespace", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_UpdateNamespaceResponse{UpdateNamespaceResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_DeleteNamespaceRequest:
		r, err := a.grackleNamespacesCore.DeleteNamespace(req.DeleteNamespaceRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleNamespaces", "DeleteNamespace", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_DeleteNamespaceResponse{DeleteNamespaceResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(updateResponse)
	if err != nil {
		panic(err)
	}

	return response
}

func (a *GrackleNamespacesCoreAdapter) Read(request []byte) []byte {
	readRequest := &corepb.GrackleReadRequest{}
	readResponse := &corepb.GrackleReadResponse{}

	err := proto.Unmarshal(request, readRequest)
	if err != nil {
		panic(err)
	}

	t1 := time.Now()

	switch req := readRequest.Request.(type) {
	case *corepb.GrackleReadRequest_GetNamespaceRequest:
		r, err := a.grackleNamespacesCore.GetNamespace(req.GetNamespaceRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleNamespaces", "GetNamespace", a.shardId, a.replicaId), t1)
		readResponse.Response = &corepb.GrackleReadResponse_GetNamespaceResponse{GetNamespaceResponse: r}
		readResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleReadRequest_ListNamespacesRequest:
		r, err := a.grackleNamespacesCore.ListNamespaces(req.ListNamespacesRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleNamespaces", "ListNamespaces", a.shardId, a.replicaId), t1)
		readResponse.Response = &corepb.GrackleReadResponse_ListNamespacesResponse{ListNamespacesResponse: r}
		readResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(readResponse)
	if err != nil {
		panic(err)
	}

	return response
}

type GrackleWaitGroupsCoreAdapter struct {
	shardId   string
	replicaId string

	grackleWaitGroupsCore GrackleWaitGroupsCoreApi
}

var _ monstera.ApplicationCore = &GrackleWaitGroupsCoreAdapter{}

func NewGrackleWaitGroupsCoreAdapter(shardId string, replicaId string, grackleWaitGroupsCore GrackleWaitGroupsCoreApi) *GrackleWaitGroupsCoreAdapter {
	return &GrackleWaitGroupsCoreAdapter{
		grackleWaitGroupsCore: grackleWaitGroupsCore,
		replicaId:             replicaId,
		shardId:               shardId,
	}
}

func (a *GrackleWaitGroupsCoreAdapter) Snapshot() monstera.ApplicationCoreSnapshot {
	defer monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleWaitGroups", "Snapshot", a.shardId, a.replicaId), time.Now())

	return a.grackleWaitGroupsCore.Snapshot()
}

func (a *GrackleWaitGroupsCoreAdapter) Restore(r io.ReadCloser) error {
	defer monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleWaitGroups", "Restore", a.shardId, a.replicaId), time.Now())

	return a.grackleWaitGroupsCore.Restore(r)
}

func (a *GrackleWaitGroupsCoreAdapter) Close() {
	a.grackleWaitGroupsCore.Close()
}

func (a *GrackleWaitGroupsCoreAdapter) Update(request []byte) []byte {
	updateRequest := &corepb.GrackleUpdateRequest{}
	updateResponse := &corepb.GrackleUpdateResponse{}

	err := proto.Unmarshal(request, updateRequest)
	if err != nil {
		panic(err)
	}

	t1 := time.Now()

	switch req := updateRequest.Request.(type) {
	case *corepb.GrackleUpdateRequest_AddJobsToWaitGroupRequest:
		r, err := a.grackleWaitGroupsCore.AddJobsToWaitGroup(req.AddJobsToWaitGroupRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleWaitGroups", "AddJobsToWaitGroup", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_AddJobsToWaitGroupResponse{AddJobsToWaitGroupResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_CompleteJobsFromWaitGroupRequest:
		r, err := a.grackleWaitGroupsCore.CompleteJobsFromWaitGroup(req.CompleteJobsFromWaitGroupRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleWaitGroups", "CompleteJobsFromWaitGroup", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_CompleteJobsFromWaitGroupResponse{CompleteJobsFromWaitGroupResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_CreateWaitGroupRequest:
		r, err := a.grackleWaitGroupsCore.CreateWaitGroup(req.CreateWaitGroupRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleWaitGroups", "CreateWaitGroup", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_CreateWaitGroupResponse{CreateWaitGroupResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_DeleteWaitGroupRequest:
		r, err := a.grackleWaitGroupsCore.DeleteWaitGroup(req.DeleteWaitGroupRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleWaitGroups", "DeleteWaitGroup", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_DeleteWaitGroupResponse{DeleteWaitGroupResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_RunWaitGroupsGarbageCollectionRequest:
		r, err := a.grackleWaitGroupsCore.RunWaitGroupsGarbageCollection(req.RunWaitGroupsGarbageCollectionRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleWaitGroups", "RunWaitGroupsGarbageCollection", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_RunWaitGroupsGarbageCollectionResponse{RunWaitGroupsGarbageCollectionResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleUpdateRequest_WaitGroupsDeleteNamespaceRequest:
		r, err := a.grackleWaitGroupsCore.WaitGroupsDeleteNamespace(req.WaitGroupsDeleteNamespaceRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleWaitGroups", "WaitGroupsDeleteNamespace", a.shardId, a.replicaId), t1)
		updateResponse.Response = &corepb.GrackleUpdateResponse_WaitGroupsDeleteNamespaceResponse{WaitGroupsDeleteNamespaceResponse: r}
		updateResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(updateResponse)
	if err != nil {
		panic(err)
	}

	return response
}

func (a *GrackleWaitGroupsCoreAdapter) Read(request []byte) []byte {
	readRequest := &corepb.GrackleReadRequest{}
	readResponse := &corepb.GrackleReadResponse{}

	err := proto.Unmarshal(request, readRequest)
	if err != nil {
		panic(err)
	}

	t1 := time.Now()

	switch req := readRequest.Request.(type) {
	case *corepb.GrackleReadRequest_GetWaitGroupRequest:
		r, err := a.grackleWaitGroupsCore.GetWaitGroup(req.GetWaitGroupRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleWaitGroups", "GetWaitGroup", a.shardId, a.replicaId), t1)
		readResponse.Response = &corepb.GrackleReadResponse_GetWaitGroupResponse{GetWaitGroupResponse: r}
		readResponse.Error = monsterax.WrapError(err)
	case *corepb.GrackleReadRequest_ListWaitGroupsRequest:
		r, err := a.grackleWaitGroupsCore.ListWaitGroups(req.ListWaitGroupsRequest)
		monsterax.MeasureSince(monsteraCoreMethodDuration.WithLabelValues("GrackleWaitGroups", "ListWaitGroups", a.shardId, a.replicaId), t1)
		readResponse.Response = &corepb.GrackleReadResponse_ListWaitGroupsResponse{ListWaitGroupsResponse: r}
		readResponse.Error = monsterax.WrapError(err)
	default:
		panic("no matching handlers")
	}
	response, err := proto.Marshal(readResponse)
	if err != nil {
		panic(err)
	}

	return response
}
